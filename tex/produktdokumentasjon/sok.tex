\section{Søk} \label{sec:sok}
Generelt i programmet finnes det to måter å søke data på: (1) fritekstsøk som kan foretas av megler samt (2) annonsefilter som foretas av boligsøker. Megleren begrenser sit søk til et spesifikk register f.eks. boligregister eller utleierregister og mottar søkeresultat baser på den tekst som er skrevet inn i tekstfeltet. Megleren kan også hente opp en full\footnote{Foreløpig er det ikke implementert en begrensing her, dersom programmet skal brukes til store datamengder borde det innføres en begrensning på antall rader som kan hentes opp til tabellen.} registerliste gjennom å bruke et tomt søkefelt eller stjerne "<*">. 
En boligsøker får sitt søkeresultat filtrert gjennom å bruke kriterier som poststed, boligtype, boligstørrelse [$m^2$] og utleiepris. Dersom søkeren ikke bruker boligstørrelse eller utleiepris om parameter vil annonsene blir filtrert på poststed og boligtype.
Søkeklasser er plassert i \emph{search} pakken og består av \emph{FreeTextSearch.java} (megler) samt \emph{AnnonseFilter.java} (boligsøker).

\subsection{Meglersøk}
Fritekstsøk for megler består i bunn av en klasse og et interface:
\begin{description}
\item[\emph{FreeTextSearch.java}] klassen bruker en interator for søk igjennom en generisk \emph{HashSet} over klasser som implementerer interface \emph{Searchable}
\item[\emph{Searchable.java}] er et interface som er påkrevd av alle klasser som skal være mulig å bruke FreeTextSearch på. iterfacet krever at hver klasse implemetrer metoden \emph{toSearch()} som returnerer en \emph{String[]} over datafelt i klassen som man skal kunne søke tillempe søket på.
\end{description}

Fritekstsøk blir gjennomført på en av regsitrene som brukeren velger, f.eks. boligregister, utleierregister, annonseregister, mm. Søket foretas over datafelt i de klasser som inngår i et spesifikt register. For at en klasse skal kunne inngå i søket må den implementere interface \emph{Se}

\begin{lstlisting}[caption=Oversikt over \emph{Searchable} interface, label=kode:msg1]
	public interface Searchable {
   		String[] toSearch();
	}
\end{lstlisting}

\begin{lstlisting}[caption=Implemntasjon av metode \emph{toSearch() i klassen Person.java}, label=kode:mgs2]
	@Override
    public String[] toSearch(){
        String[] searchFields = {
            String.valueOf(personID), 
            fornavn, 
            etternavn, 
            epost, 
            telefon};
        
        return searchFields;
    }
\end{lstlisting}


\begin{lstlisting}[caption=Iterasjon over generisk \emph{HashSet} som implementerer interface \emph{Searchable}, label=kode:msg3]
    public ArrayList<T> searchForPattern(HashSet<? extends Searchable> liste, String pattern) {

        pattern = pattern.trim();
        pattern = pattern.toLowerCase();

        if (liste != null) {
            if (pattern.equalsIgnoreCase("søk") || pattern.equals("") || pattern.equals("*")) {
                for (Searchable o : liste) {
                    resultList.add((T) o);
                }
            } else {
                for (Searchable o : liste) {
                    checkMeForResults = o.toSearch();

                    for (String s : checkMeForResults) {
                        s = s.toLowerCase();
                        if (s.contains(pattern)) {
                            resultList.add((T) o);
                        }
                    }
                }
            }
            return resultList;
        } else {
            System.out.println("En tom liste ble sendt inn til søkemetoden");
            return null;
        }
    }
\end{lstlisting}

\subsection{Annonsefilter} \label{sec:annonsesok}
I seksjonen følger en beskrivelse av \emph{AnnonseFilter.java}. Kontruktøren til klassen tar i mot et HashSet over annonse objekter (\emph{HashSet<Annonse>}). Klassen internt jobber med tre HashSet som brukes mellom filtreringstrinn hvilke blir satt i konstruktøren, se eksempel \ref{kode:annonsefilterkostn}. \emph{annonseListeTmp} brukes mellom filtreringstrinn og \emph{annonseListeFiltrert} blir brukt til ferdigfiltrerte resultat.  

\begin{lstlisting}[caption=AnnonseFilter.java: Konstruktør, label=kode:annonsefilterkostn]
    public AnnonseFilter(HashSet<Annonse> annonseliste) {
        this.annonseListeOriginal = annonseliste;
        annonseListeFiltrert = new HashSet<>();
        annonseListeTmp = new HashSet<>();
    }
\end{lstlisting}

Uansett hvis brukeren legger inn alle filtreringsparametre eller ikke vil fltreringen altid forregå internt etter en og samem rekkefølge etter: (1) poststed, (2) boligtype, (3) utleiepris, (4) boligstørrelse (5) resterende parametre som fellesvask, hage og kjeller. Alle parametrene blir sendt til filtreringmetoden vis kontroller for TopPanel i AnnonseArkFane. Selve interne filtreringsalgortimen foretar følgende trinn ved filtrering:
\begin{enumerate}
\item For hver element i \emph{annonseListeOriginal} kontroller dersom \underline{poststed} stemmer og kopier elementet til annonseListeTmp. Etter at ha interert over alle elementer gå kopier annonseListeTmp til annonseListeFiltrert. 
\item For hvert element i annonseListeFiltrert kontrollere dersom \underline{boligtype} stemmer og kopier hver da elementet til annonseListeTmp. Etter at ha interert gjennom alle elementer i annonseListeFiltrert skriv over den listen med innhold ra listen annonseListeFiltrert. 
\item Foreta samme tilnærmingsmåte som i trinn 2 for alle søkeparametre. 
\item Returner filtrert set \emph{HashSet<Annonse> annonseListeFiltrert}.
\end{enumerate}

I eksempel \ref{kode:filtrering2} presenteres rekkefølges som foretas på den interne filtrering. Metoden kaller opp et flertall interne metoder som foretar filtrering for hver enkel parameter sendt fra kontrolleren. I eksempel \ref{kode:filtrering3} viser hvordan filtreringen foretas i en provat metoden, som i dette eksemplet blir data filtrert på \textit{min} og \textit{maks} pris. Filtrering i de øvrig private metodene blir foretatt på en relativt analog måte (henviser spesielt intereserte til å eventuelt betrakte løsningen i selve kildekoden til oppgaven). 

\begin{lstlisting}[caption=AnnonseFilter.java: Filtreringsrekkefølge etter mottatte parametre, label=kode:filtrering2]
	public HashSet<Annonse> filtrerEtterParametre(String poststed, Boligtype boligtype, int prisMin, int prisMaks, int arealMin, int arealMaks, boolean harBalkong, boolean harFellesvask, boolean harHage, boolean harKjeller) {
        filtrerEtterPostSted(poststed);
        filtrerEtterBoligType(boligtype);
        filtrerEtterPrisRange(prisMin, prisMaks);
        filtrerEtterBoArealRange(arealMin, arealMaks);
        if (harBalkong) {
            filtrerEtterBalkong();
        }
        if (harFellesvask) {
            filtrerEtterFellesvaskeri();
        }
        if (harHage) {
            filtrerEtterHage();
        }
        if (harKjeller) {
            filtrerEtterKjeller();
        }
        return getFilteredResults();
    	}
\end{lstlisting}
    
\begin{lstlisting}[caption=AnnonseFilter.java: Eksepel på privat filtreringsklasse etter bolig areal som foretas mellom trinn for pris og balkong., label=kode:filtrering3]
    private void filtrerEtterBoArealRange(int min, int maks) {
        if (min != 0 && maks != 0) {
            for (Annonse a : annonseListeFiltrert) {
                if (a.getBolig() != null) {
                    if (min <= a.getBolig().getBoAreal() && a.getBolig().getBoAreal() <= maks) {
                        annonseListeTmp.add(a);
                    }
                }
            }
            kopierTilFiltrerteResultat();
        }
    }
\end{lstlisting}