\section{Søk} \label{sec:sok}
Generelt i programmet finnes det to måter å søke data på: (1) fritekstsøk som kan foretas av megler samt (2) annonsefilter som foretas av boligsøker. Megleren begrenser sit søk til et spesifikk register f.eks. boligregister eller utleierregister og mottar søkeresultat baser på den tekst som er skrevet inn i tekstfeltet. Megleren kan også hente opp en full\footnote{Foreløpig er det ikke implementert en begrensing her, dersom programmet skal brukes til store datamengder borde det innføres en begrensning på antall rader som kan hentes opp til tabellen.} registerliste gjennom å bruke et tomt søkefelt eller stjerne "<*">. 
En boligsøker får sitt søkeresultat filtrert gjennom å bruke kriterier som poststed, boligtype, boligstørrelse [$m^2$] og utleiepris. Dersom søkeren ikke bruker boligstørrelse eller utleiepris om parameter vil annonsene blir filtrert på poststed og boligtype.
Søkeklasser er plassert i \texttt{search} pakken og består av \texttt{FreeTextSearch.java} (megler) samt \texttt{AnnonseFilter.java} (boligsøker).

\subsection{Meglersøk} \label{subsec:sok:megler}
Fritekstsøk for megler består i bunn av en klasse og et interface:
\begin{description}
\item[\texttt{FreeTextSearch.java}] klassen bruker en interator for søk igjennom en generisk \texttt{HashSet} over klasser som implementerer interface \texttt{Searchable}
\item[\texttt{Searchable.java}] er et interface som er påkrevd av alle klasser som skal være mulig å bruke FreeTextSearch på. iterfacet krever at hver klasse implemetrer metoden \texttt{toSearch()} som returnerer en \texttt{String[]} over datafelt i klassen som man skal kunne søke tillempe søket på.
\end{description}

Fritekstsøk blir gjennomført på en av regsitrene som brukeren velger, f.eks. boligregister, utleierregister, annonseregister, mm. Søket foretas over datafelt i de klasser som inngår i et spesifikt register. For at en klasse skal kunne inngå i søket må den implementere interface \texttt{Serchable} som i sin tur stiller krav på metode å legget til en metode som returnerer en \texttt{String[]} over de datafelt som søket skal gå over (eksepel \ref{kode:mgs1} og \ref{kode:mgs2} vis oppbygging interfacet og implementering av metode \texttt{toSearch()}). En slik implemntering gjør det enkelt å implementers økemetoder uten å bruke mye kode som går henter datafelt via klassens egne \texttt{get} metoder. Samtidig dersom man i fremtiden ønsker innkludere flere datafelt i klassene som skal inngå i søket kan disse på en enkel på implementere i søket.

\begin{lstlisting}[caption=Oversikt over \texttt{Searchable} interface, label=kode:mgs1]
	public interface Searchable {
   		String[] toSearch();
	}
\end{lstlisting}

\begin{lstlisting}[caption=Implemntasjon av metode \texttt{toSearch() i klassen Person.java}, label=kode:mgs2]
	@Override
    public String[] toSearch(){
        String[] searchFields = {
            String.valueOf(personID), 
            fornavn, 
            etternavn, 
            epost, 
            telefon};
        
        return searchFields;
    }
\end{lstlisting}

I eksepel \ref{kode:mgs3} presenteres selve intereringen over objektene i et generisk \texttt{HashSet} som implementerer interfacet. Metoden \texttt{searchForPattern()} tar inn genersik hash set med begrensning for interface og en tekststreng som innholde søkeparrametern. Den innkommende søkeparameteren blir renset på eventuelle blanksteg og satt til "<lowercase">. Først blir søkeparametern testet på dersom brukeren har forsøkt å søke på en tom liste eller med en annen parameter som forutsetter at man ønsker å returnere alle søkeresultat. Hvis ikke så itererer vi gjennom settet mottat som parameter med interface \texttt{Searchable} og for hver treff blir arrayen med datafelt i form av strng gjennomsøkt etter treffer med String metoden \texttt{contains(String s)}. 

\begin{lstlisting}[caption=Iterasjon over generisk \texttt{HashSet} som implementerer interface \texttt{Searchable}, label=kode:mgs3]
    public ArrayList<T> searchForPattern(HashSet<? extends Searchable> liste, String pattern) {

        pattern = pattern.trim();
        pattern = pattern.toLowerCase();

        if (liste != null) {
            if (pattern.equalsIgnoreCase("søk") || pattern.equals("") || pattern.equals("*")) {
                for (Searchable o : liste) {
                    resultList.add((T) o);
                }
            } else {
                for (Searchable o : liste) {
                    checkMeForResults = o.toSearch();

                    for (String s : checkMeForResults) {
                        s = s.toLowerCase();
                        if (s.contains(pattern)) {
                            resultList.add((T) o);
                        }
                    }
                }
            }
            return resultList;
        } else {
            System.out.println("En tom liste ble sendt inn til søkemetoden");
            return null;
        }
    }
\end{lstlisting}

Vi er kjent med begrensninger som finnes i denne søkemetoden, disse diskutteres i detalj i avsnitt \ref{subsec:begrensinger:sok}, side \pageref{subsec:begrensinger:sok}.

\subsection{Annonsefilter}
I seksjonen følger en beskrivelse av \texttt{AnnonseFilter.java}. Kontruktøren til klassen tar i mot et HashSet over annonse objekter (\texttt{HashSet<Annonse>}). Klassen internt jobber med tre HashSet som brukes mellom filtreringstrinn hvilke blir satt i konstruktøren, se eksempel \ref{kode:annonsefilterkostn}. \texttt{annonseListeTmp} brukes mellom filtreringstrinn og \texttt{annonseListeFiltrert} blir brukt til ferdigfiltrerte resultat.  

\begin{lstlisting}[caption=AnnonseFilter.java: Konstruktør, label=kode:annonsefilterkostn]
    public AnnonseFilter(HashSet<Annonse> annonseliste) {
        this.annonseListeOriginal = annonseliste;
        annonseListeFiltrert = new HashSet<>();
        annonseListeTmp = new HashSet<>();
    }
\end{lstlisting}

Uansett hvis brukeren legger inn alle filtreringsparametre eller ikke vil fltreringen altid forregå internt etter en og samem rekkefølge etter: (1) poststed, (2) boligtype, (3) utleiepris, (4) boligstørrelse (5) resterende parametre som fellesvask, hage og kjeller. Alle parametrene blir sendt til filtreringmetoden vis kontroller for TopPanel i AnnonseArkFane. Selve interne filtreringsalgortimen foretar følgende trinn ved filtrering:
\begin{enumerate}
\item For hver element i \texttt{annonseListeOriginal} kontroller dersom \underline{poststed} stemmer og kopier elementet til annonseListeTmp. Etter at ha interert over alle elementer gå kopier annonseListeTmp til annonseListeFiltrert. 
\item For hvert element i annonseListeFiltrert kontrollere dersom \underline{boligtype} stemmer og kopier hver da elementet til annonseListeTmp. Etter at ha interert gjennom alle elementer i annonseListeFiltrert skriv over den listen med innhold ra listen annonseListeFiltrert. 
\item Foreta samme tilnærmingsmåte som i trinn 2 for alle søkeparametre. 
\item Returner filtrert set \texttt{HashSet<Annonse> annonseListeFiltrert}.
\end{enumerate}

I eksempel \ref{kode:filtrering2} presenteres rekkefølges som foretas på den interne filtrering. Metoden kaller opp et flertall interne metoder som foretar filtrering for hver enkel parameter sendt fra kontrolleren. I eksempel \ref{kode:filtrering3} viser hvordan filtreringen foretas i en provat metoden, som i dette eksemplet blir data filtrert på \textit{min} og \textit{maks} pris. Filtrering i de øvrig private metodene blir foretatt på en relativt analog måte (henviser spesielt intereserte til å eventuelt betrakte løsningen i selve kildekoden til oppgaven). 

\begin{lstlisting}[caption=AnnonseFilter.java: Filtreringsrekkefølge etter mottatte parametre, label=kode:filtrering2]
	public HashSet<Annonse> filtrerEtterParametre(String poststed, Boligtype boligtype, int prisMin, int prisMaks, int arealMin, int arealMaks, boolean harBalkong, boolean harFellesvask, boolean harHage, boolean harKjeller) {
        filtrerEtterPostSted(poststed);
        filtrerEtterBoligType(boligtype);
        filtrerEtterPrisRange(prisMin, prisMaks);
        filtrerEtterBoArealRange(arealMin, arealMaks);
        if (harBalkong) {
            filtrerEtterBalkong();
        }
        if (harFellesvask) {
            filtrerEtterFellesvaskeri();
        }
        if (harHage) {
            filtrerEtterHage();
        }
        if (harKjeller) {
            filtrerEtterKjeller();
        }
        return getFilteredResults();
    	}
\end{lstlisting}
    
\begin{lstlisting}[caption=AnnonseFilter.java: Eksepel på privat filtreringsklasse etter bolig areal som foretas mellom trinn for pris og balkong., label=kode:filtrering3]
    private void filtrerEtterBoArealRange(int min, int maks) {
        if (min != 0 && maks != 0) {
            for (Annonse a : annonseListeFiltrert) {
                if (a.getBolig() != null) {
                    if (min <= a.getBolig().getBoAreal() && a.getBolig().getBoAreal() <= maks) {
                        annonseListeTmp.add(a);
                    }
                }
            }
            kopierTilFiltrerteResultat();
        }
    }
\end{lstlisting}