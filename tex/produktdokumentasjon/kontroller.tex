\section{Kontroller \texttt{(Controller)}} \label{sec:kontroller}

\subsection{Generelt om kontrollermiljøet}
Da prosjektet startet var vi fornøyd med én \texttt{kontroller} og kalte den \texttt{MainController.java}. Det viste seg ganske raskt at den ville kunne bli enormt stor, så da endte vi opp med å dele den opp i flere deler. Siden den gang har vi besluttet at vi like godt kunne ha én \texttt{kontroller} til hvert vindu, og kanskje noen uten tilhørende vinduer også.
\texttt{MainController} instansierer alle \texttt{hovedkontrollerne}, bortsett fra \texttt{BunnController} som instansieres fra \texttt{ControllerTabell} og \texttt{ControllerOutput} som ikke instansieres. Den har bare statiske metoder som tar i mot diverse data og viser dem i \texttt{JEditorPane} formatert som \texttt{HTML}.

I tillegg til \texttt{hovedkontrollerne} har vi \texttt{registreringskontrollerne} som hører til hvert sitt registreringsvindu. De vil bli nevnt under \ref{sec:regkontrollere} på side \pageref{sec:regkontrollere}.

Det er et eget avsnitt i dette kapitelet vedrørende lyttefunksjonaliten vi har implementert for å kunne kommunisere mellom de forskjellige \texttt{kontrollerne} .

I den første delen av prosjektet var ikke \texttt{JTable}-implementasjonen vår veldig god og vi kunne ikke benytte oss av å teste hvilket datasett som var satt i tabellen. Dermed endte vi opp med å bruke identifikatorer for dette. Først med \texttt{konstanter} og så \texttt{Enum} som identifiserte personobjekter, boligobjektet osv.
Vi måtte derfor implementere \texttt{Interface}-lyttere som lyttet på når en ny \texttt{ArrayList} var satt i tabellen blant annet.

Siden det har tabellen kommet skikkelig på plass og det går nå an å teste hvilken type objekter som ligger i tabellen. Dermed har vi til dels begynt å teste på tabellens \texttt{getModel()}-metode for å finne instansen av datasettet.

Siden vi likevel er veldig  stolte av løsningen vår med \texttt{interface}-lyttere har vi valgt å beholde noe av implementasjonen og vil derfor ha et eget delkapittel for dette her \ref{sec:kontrollerlyttere}, på side \pageref{sec:kontrollerlyttere}.


\subsection{Hovedkontrollerne}
\texttt{Hovedkontrollerne} er betegnelsen på klassene:
\begin{itemize}[noitemsep,nolistsep]
\item \texttt{MainController.java} 
\item \texttt{ControllerTabell.java} 
\item \texttt{ControllerOutput.java}
\item \texttt{ControllerBunnPanel.java}
\item \texttt{ControllerToppPanelMegler.java} 
\item \texttt{ControllerToppPanelAnnonse.java}
\end{itemize}
Disse \texttt{kontrollerne} styrer absolutt all funksjonalitet mellom datastrukturen og brukergrensesnittet.


\subsection{\texttt{MainController.java}}
Denne klassen instansieres fra \texttt{SkrivTilLesFraFil.java}, der data blir lest inn fra fil og skrevet til fil.
Denne klassen har ikke noe brukergrensesnitt og den eneste oppgaven den har er å starte andre \texttt{kontrollere} og brukergrensesnittet.
I tillegg til det passer \texttt{kontrolleren} på at de andre komponentene som skal kommunisere sammen har mulighet til det. Dette er løst med en lytteløsning beskrevet her \ref{sec:kontrollerlyttere}, på side \pageref{sec:kontrollerlyttere}.


\subsection{\texttt{ControllerToppPanelMegler.java}}
Brukergrensesnittet til denne klassen gir megler mulighet til å søke i de forskjellige datasettene, samt registrere nye objekter.
I tillegg er det er enkelt statistikkpanel som viser antall ledige boliger og antall kontrakter signert i år.

Klassens primære funksjon er søkefunksjonaliteten og videresending av resultatet til tabellen.
Metoden \texttt{finnValgtObjektITabell} har en \texttt{ListSelectionListener} som lytter på tabellens \texttt{valueChanged}. Hver gang en ny rad er valgt i tabellen så returneres nummeret på raden som er valgt. Om verdien som returneres er forskjellig fra \texttt{-1} (når tabellen ikke har en valgt rad returneres -1) så konverteres nummeret til den bakenforliggende tabellmodellens index. Til slutt så lagres det et \texttt{Object valgtObjekt} som hentes på den indexen som er angitt.

Metoden \texttt{sendSokeResultat} tar i mot en streng fra søkefeltet, og avhengig av hvilken \texttt{radioknapp} som er valgt så kjøres søkemetoden på det rette datasettet. Resultatet lagres i en ArrayList. Søkemetoden er beskrevet nærmere her \ref{sec:sok}, på side \pageref{sec:sok}.
Resultatet blir så sendt ned til tabellen og vist der. Det skjer via \texttt{lytteren} som blir vist ved eksempel her \ref{sec:kontrollerlyttere}, på side \pageref{sec:kontrollerlyttere}.
Den private klassen \texttt{KnappeLytter} lytter på de fire knappene i brukergrensesnittet. Metodene tester på hvilken type objektet som er valgt i tabellen er og man får bare trykke på vedrørende knapp om det man ønsker å utføre er relevant.
Eksempelvis så skal man ikke kunne trykke på "Ny Bolig" uten å ha først valgt et personobjekt av typen \texttt{Utleier} i tabellen.

\subsection{\texttt{ControllerToppPanelAnnonse.java}}
Denne \texttt{kontrolleren} er mer avansert enn \texttt{ControllerToppPanelMegler.java}. Klassen benytter seg av et \texttt{AnnonseFilter} som er beskrevet i detalj her \ref{sec:annonsesok}, på side \pageref{sec:annonsesok}.
\texttt{Annonsefilteret} har to \texttt{get-metoder} som brukes for å fyllet ut de to \texttt{komboboksene} som lister boligtyper og poststeder. Det er metodene \texttt{addPoststederToComboBoxOnLoad} og \texttt{addBoligTyperToComboBoxOnLoad} som tar seg av denne jobben.
\texttt{Komboboksen} som lister opp poststed er implementert slik at den søker gjennom alle annonsene som er publisert og henter poststedet inn i listen. Det vil si at når én annonse forsvinner, så forsvinner også poststedet fra \texttt{komboboksen} også, så sant det ikke er andre annonser publisert for en bolig på samme poststed.

I det man trykker på søkeknappen i brukergrensesnittet så kjøres metoden \texttt{sendSokeResultat}. Denne metoden kjører så metoden \texttt{filtrerAnnonser}, og om \texttt{lytteren} er instansiert så sendes datasettet ned til tabellen via \texttt{interfacet} som står for kontakten mellom \texttt{kontrollerne}. Denne lyttefunksjonaliteten blir vist ved eksempel her \ref{sec:kontrollerlyttere}, på side \pageref{sec:kontrollerlyttere}.

Metoden \texttt{filtrerAnnonser} nevnt overnfor henter søkekriterier fra brukergrensesnittet og om kriteriene passerer RegEx-testen så sendes de med til \texttt{annonsefilteret} som parametere. Returen fra denne metoden er et \texttt{HashSet} av annonser.


\subsection{\texttt{ControllerBunnPanel.java}}
Denne klassen instansieres fra \texttt{ControllerTabell.java} i motsetning til de andre \texttt{kontrollerne}. Denne klassen har tre knapper som brukes i forbindelse med navigering i tabellen, samt til å åpne registreringsvinduet for valgt objekt for endring.
Klassen har én privat \texttt{KnappeLytter}-klasse som utgjør omtrent hele funksjonaliteten til denne \texttt{kontrolleren}.
Den ene knappen her har forskjellig funksjonalitet om man er i \texttt{annonseVindu} enn om man er i \texttt{meglerVindu}.
\texttt{Konstruktøren} til \texttt{KnappeLytteren} endrer navn på \texttt{MultiKnapp} som vi har valgt å kalle den. 
I \texttt{actionPerformed}-metoden vil det testes for hvilket datasett som ligger i tabellen, hvilken rad som er valgt, og hvilket vindu man befinner seg i. Se følgende eksempel \ref{kode:contbpan}:

\begin{lstlisting}[caption={[\texttt{ControllerBunnPanel.java}]Utdrag fra \texttt{actionPerformed}-metoden i \texttt{ControllerBunnPanel.java}}, label=kode:contbpan]
    if (tabell.getModel() instanceof TabellModellAnnonse) {
        modellIBruk = (TabellModellAnnonse) modellIBruk;
        if (vindu instanceof ArkfaneMegler) {
            new ControllerRegistrerAnnonse(annonseliste, personliste, (Annonse) modellIBruk.finnObjektIModell(valgtRad));
        } else {
            new ControllerRegistrerSoknad(personliste, annonseliste, soknadliste, (Annonse) modellIBruk.finnObjektIModell(valgtRad));
        }
    }
\end{lstlisting}

\subsection{\texttt{ControllerOutput.java}} \label{subsec:contout}
\texttt{SenterPanel.java} har én komponent som viser valgt objekt i tabellen i \texttt{HTML}visning. Alle metodene i denne klassen er statiske. De skal ikke behandle objekter, bare vise dem. Denne \texttt{kontrolleren} er derfor ikke instansiert noe sted.
Alle "<\texttt{HTML}-metodene"> tar i mot \texttt{JEditorPane}-komponenten det skal skrives til, i hvilket vindu man befinner seg i, objektet som skal vises og eventuelt et eller flere \texttt{HashSet} om en trenger ytterligere informasjon i utskriften.

\texttt{Utleier}-objekter har i visningen blant annet en liste over boliger de eier, om noen. Da er det hjelpemetoder som itererer over \texttt{boligregisteret} og finner eieren av hver \texttt{bolig}. \texttt{Boligene} til valgt valgt \texttt{Utleier} vil da returneres og skrives ut i \texttt{Utleier}-objektet.

Ut over selve metodene for å vise objekter så finnes metoden \texttt{setStylesheet} helt nederst i klassen.
Alle "<\texttt{HTML}-metodene"> må formateres så de passer inn i vinduet \texttt{JEditorPane} har tilgjengelig. 
Det er stort sett brukt tabeller for å vise objekter, og da \texttt{JEditorPane} ikke støtter nyere \texttt{HTML}-versjon enn 3.2 med \texttt{CSS} 1.0, så har vi vært ganske begrenset på hvor for seg gjort visningene kunne bli.
Det måtte en del justering på plass, da en ikke kan automatisk skalere bilder, som i nyere versjoner av \texttt{HTML}.


\subsection{\texttt{ControllerTabell.java}}
Denne \texttt{kontrolleren} er holder orden på alle data som skal vises i tabellen i \texttt{VenstrePanel.java} der tabellen ligger, samt funksjonalitet for å slette, endre og opprette nye objekter. \\
Dette kapittelet vil ta for seg noen nøkkelpunkter på funksjonalitet og flyt av data.

$\bullet$ Hvordan tabellen tar i mot data og settes opp, side \pageref{sec:oppsettabell} \\ 
$\bullet$ Datamodellene, sortering og formatering, side \pageref{sec:virkemåtetabell} \\
$\bullet$ PopupMeny-funksjonalitet, side \pageref{sec:interaktivitettabell} \\
$\bullet$ Lytter på klikk i Output-vinduet, side \pageref{sec:interaktivitettabell}


\subsubsection{Hvordan \texttt{kontrolleren} setter opp tabellen} \label{sec:oppsettabell}
I det programmet starter opp kaller \texttt{MainController.java} opp to metoder i \texttt{TabellController.java}, \texttt{settOppTabellLyttere} og \texttt{settInnDataITabell}.
Den første av disse tar for seg en hel del initialisering av tabellens virkemåte. Den andre tar i mot et datasett og setter det inn i tabellen. Den metoden vil bli beskrevet mer i avsnittet for tabellens virkemåte \ref{sec:virkemåtetabell}, side \pageref{sec:virkemåtetabell}.

En \texttt{JTable} har muligheter for utrolig mye funksjonalitet om en velger å ta det i bruk.
Vår implementasjon er for så vidt litt annerledes enn en del av eksemplene en kan lese om andre steder. Vi har valgt å ikke tillate endring i tabellen. En \texttt{JList} fant vi fort ut var for enkel, da vi gjerne også ville kunne sortere på kolonner.

I prosessen har vi endret tabellens datastruktur to ganger. Først ble det blant annet brukt en \texttt{array}, men da den er vanskelig å slette fra uten mye ekstra prosessering så endte vi opp med en \texttt{ArrayList} som datastruktur. Da vår tabell skal liste ett objekt per linje, så valgte vi ikke å bruke en flerdimensjonal \texttt{array}. 

Metoden \texttt{settOppTabellLyttere} gjør litt mer enn bare å sette opp \texttt{lyttere}. Først initialiserer den \texttt{ControllerBunnPanel.java} sin private \texttt{lytteklasse}.
Videre kalles metoden \texttt{settOpplyttereForPopupMenyITabell} som definerer funksjonaliteten til \texttt{PopupMenu} når en høyreklikker i tabellen. Les mer om den på \ref{sec:interaktivitettabell}, på side \pageref{sec:interaktivitettabell}.
Metoden kobler så tabellen og popupmenyen sammen via tabellens \texttt{setComponentPopUpMenu}-metode, før den initialiserer slettefunksjonalitet i tabellen når en bruker \texttt{Delete}-knappen på tastaturet. Se følgende eksempel (\ref{kode:slett1}):
\begin{lstlisting}[caption=Slettefunksjonalitet i tabellen ved å trykke Delete på tastaturet.,label=kode:slett1]
        inputMap = tabell.getInputMap(JTable.WHEN_FOCUSED);
        actionMap = tabell.getActionMap();

        Action sletteknappFunksjon = new AbstractAction() {
            @Override
            public void actionPerformed(ActionEvent e) {
                generellSletteMetodeSomKallerOppRettSletteMetode();
            }
        };

        inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_DELETE, 0), "Slett");
        inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_BACK_SPACE, 0), "Slett");
        actionMap.put("Slett", sletteknappFunksjon);
\end{lstlisting}


Metoden som kalles opp \texttt{generellSletteMetodeSomKallerOppRettSletteMetode} kaller igjen på den rette metoden som faktisk utfører slettingen. Det er tre slettemetoder i \texttt{kontrolleren}; \texttt{slettPerson, slettBolig} og \texttt{slettAnnonse}.

Metoden er nå kommet for å initialisere diverse lyttere. De vil vises med eksempler. Først ut er tabellens funksjonalitet for å oppfatte hvilken rad som er valgt, og deretter kalle på metoden \texttt{sendObjektFraTabellTilOutput}. Det vil si at hver gang en ny linje velges i tabellen så kjøres denne \texttt{sendObjektFraTabellTilOutput}-metoden, som plukker opp hvilken type objekt som er valgt og sende det til output-vinduet. Se følgende eksempel (\ref{kode:lytt1}):
\begin{lstlisting}[caption=Lytteren som finner valgt rad i tabellen.,label=kode:lytt1]
        tabell.getSelectionModel().addListSelectionListener(new ListSelectionListener() {

            @Override
            public void valueChanged(ListSelectionEvent e) {

                if (e.getValueIsAdjusting()) {
                    return;
                }
                try {
                    int rad = tabell.getSelectedRow();
                    if (rad > -1) {
                        rad = tabell.convertRowIndexToModel(rad);

                        //Lagrer raden i en variabel, som brukes i andre metoder.
                        valgtRadItabell = rad;
                        sendObjektFraTabellTilOutput(objekttype);
                    }

                } catch (ArrayIndexOutOfBoundsException aiobe) {
                    System.out.println("Tabell ConvertRowIndexToModel ArrayIndexOufOfBounds");
                } catch (IndexOutOfBoundsException iobe) {
                    System.out.println("Tabell ConvertRowIndexToModel IndexOufOfBounds");
                }
            }
        });
\end{lstlisting}

De resterende \texttt{lytterne} vil bli dekket i avsnittet om interaktivitet i tabellen \ref{sec:interaktivitettabell}, på side \pageref{sec:interaktivitettabell}.


\subsubsection{Tabellens oppsett, virkemåte og formatering} \label{sec:virkemåtetabell}

En \texttt{JTable} kan implementeres på forskjellige måter. Ofte holder det med å implementere en \texttt{DefaultTableModel}, men i vårt tilfelle der vi har forskjellige typer objekter som krever forskjellige kolonnenavn så har vi valgt å la klassen \texttt{TabellModell.java} arve \texttt{DefaultTableModel} og override de metodene vi har behov for. Videre så vil subklassene til \texttt{TabellModell.java}, som \texttt{TabellModellAnnonse.java} spesifisere hvilke kolonnenavn man har i det datasettet, samt hvilke felter i et annonseobjekt som skal hentes til hvilken kolonne. 

Klassen \texttt{VenstrePanel.java} hvor tabellen instansieres er også der man finner noe av tabellens utvidete funksjonalitet.

Metoden \texttt{settCelleRenderer} definerer hvordan spesifikke celler i tabellen skal formateres. Her er det bare definert én regel og det er for behandlede \texttt{Søknadsobjekter}. Metoden finner ut hvilken \texttt{TabellModell} som er i bruk, og så tester den kolonnen "<Er behandlet"> (nummer 2) i \texttt{TabellModellAnnonse.java} om søknaden er behandlet eller ikke. er den behandlet skal cellen "dimmes" ned. Metoden gjengis i sin helhet i eksempel \ref{kode:cellerend1} under:
\begin{lstlisting}[caption=Metoden \texttt{settCelleRenderer} fra \texttt{VenstrePanel.java}.,label=kode:cellerend1]
    public void settCelleRenderer() {

        tabell.setDefaultRenderer(Object.class, new DefaultTableCellRenderer() {
            @Override
            public Component getTableCellRendererComponent(JTable tabell, Object verdi, boolean erValgt, boolean harFokus, int rad, int kolonne) {
                TabellModell modell = (TabellModell) tabell.getModel();

                Component c = super.getTableCellRendererComponent(tabell, verdi, erValgt, harFokus, rad, kolonne);
                if (modell instanceof TabellModellSoknad) {
                    if (tabell.getValueAt(rad, 2).equals("Ja")) {
                        c.setForeground(new Color(200, 200, 200));
                    } else {
                        c.setForeground(Color.BLACK);
                    }
                }
                c.repaint();
                return c;
            }
        });

    }//End method
\end{lstlisting}

Metoden \texttt{resizeKolonneBredde} kalles opp hver gang et nytt datasett er lagt inn i tabellens modell. Metoden består av to \texttt{for}-løkker inne i hverandre som itererer gjennom alle cellene i tabellen. For hver kolonne så finner metoden den cellen som "bruker mest plass" og setter kolonnebredden til det.
Metoden er gjengitt i sin helhet i eksempel \ref{kode:resize1} under:
\begin{lstlisting}[caption=Metoden \texttt{resizeKolonneBredde} fra klassen \texttt{VenstrePanel.java},label=kode:resize1]
    public void resizeKolonneBredde() {
        TableColumnModel kolonneModell = tabell.getColumnModel();
        Component comp = null;
        TableCellRenderer renderer = null;

        for (int kol = 0; kol < tabell.getColumnCount(); kol++) {
            int bredde = 50; //minste bredde
            for (int rad = 0; rad < tabell.getRowCount(); rad++) {
                renderer = tabell.getCellRenderer(rad, kol);
                comp = tabell.prepareRenderer(renderer, rad, kol);
                bredde = Math.max(comp.getPreferredSize().width, bredde);
            }
            kolonneModell.getColumn(kol).setPreferredWidth(bredde);
        }
    }
\end{lstlisting}

Metoden \texttt{sorterTabellVedOppstart} definerer en sorteringsrekkefølge på tabellens første kolonne, slik at tabellen alltid er sortert på ID-feltet til gjeldene objekt.
Metoden \texttt{sorterTabellSoknadData} gjelder bare for \texttt{Søknadobjekter} i \texttt{TabellModellSoknad.java}. Denne sorterer først synkende på kolonnen "Er behandlet", og deretter på ID-kolonnen. Man vil da alltid ha ubehandlede søknader liggende øverst i tabellen, sortert innad på AnnonseID. 

Hvilken av disse sorteringsmetodene som tas i bruk bestemmes metoden \texttt{settInnDataITabell} i \texttt{ControllerTabell.java}.
Metoden tar inn et datasett i form av \texttt{HashSet} eller \texttt{ArrayList}, samt en \texttt{Enum}-variabel som identifiserer hvilken \texttt{radioknapp} som er valgt i søkepanelet i enten \texttt{TopPanelMegler.java} eller \texttt{TopPanelAnnonse.java}. Metoden har en \texttt{switch/case} på \texttt{Enum}-variabelen og utfører så de instuksjoner som er gjeldende for det datasettet som skal inn i tabellen.
Hele metoden er gjengitt i eksempel \ref{kode:settinn1}:
\begin{lstlisting}[caption=Metoden \texttt{settInnDataITabell} i \texttt{ControllerTabell.java},label=kode:settinn1]
    public void settInnDataITabell(Collection innkommendeDatasett, ObjektType objekttypeEnum) {

        if (innkommendeDatasett.size() > 0) {
            tabellData = new ArrayList<>();
            Iterator<?> iter = innkommendeDatasett.iterator();
            while (iter.hasNext()) {
                tabellData.add(iter.next());
            }

            try {
                switch (objekttypeEnum) {
                    case PERSONOBJ:
                        this.objekttype = ObjektType.PERSONOBJ;
                        tabellModellPerson.fyllTabellMedInnhold(tabellData);
                        tabell.setModel(tabellModellPerson);
                        tabellModellPerson.fireTableStructureChanged();
                        modellIBruk = tabellModellPerson;
                        vindu.getVenstrepanel().sorterTabellVedOppstart();
                        break;
                    case BOLIGOBJ:
                        this.objekttype = ObjektType.BOLIGOBJ;
                        tabellModellBolig.fyllTabellMedInnhold(tabellData);
                        tabell.setModel(tabellModellBolig);
                        tabellModellBolig.fireTableStructureChanged();
                        modellIBruk = tabellModellBolig;
                        vindu.getVenstrepanel().sorterTabellVedOppstart();
                        break;
                    case ANNONSEOBJ:
                        this.objekttype = ObjektType.ANNONSEOBJ;
                        tabellModellAnnonse.fyllTabellMedInnhold(tabellData);
                        tabell.setModel(tabellModellAnnonse);
                        tabellModellAnnonse.fireTableStructureChanged();
                        tabell.getColumnModel().getColumn(2).setCellRenderer(vindu.getVenstrepanel().settHoyrestilltFormateringPaaTabell());
                        tabell.getColumnModel().getColumn(3).setCellRenderer(vindu.getVenstrepanel().settHoyrestilltFormateringPaaTabell());
                        modellIBruk = tabellModellAnnonse;
                        vindu.getVenstrepanel().sorterTabellVedOppstart();
                        break;
                    case KONTRAKTOBJ:
                        this.objekttype = ObjektType.KONTRAKTOBJ;
                        tabellModellKontrakt.fyllTabellMedInnhold(tabellData);
                        tabell.setModel(tabellModellKontrakt);
                        tabellModellKontrakt.fireTableStructureChanged();
                        modellIBruk = tabellModellKontrakt;
                        vindu.getVenstrepanel().sorterTabellVedOppstart();
                        break;
                    case SOKNADSOBJ:
                        this.objekttype = ObjektType.SOKNADSOBJ;
                        tabellModellSoknad.fyllTabellMedInnhold(tabellData);
                        tabell.setModel(tabellModellSoknad);
                        tabellModellSoknad.fireTableStructureChanged();
                        modellIBruk = tabellModellSoknad;
                        vindu.getVenstrepanel().sorterTabellSoknadData();
                        break;
                }
                vindu.getVenstrepanel().resizeKolonneBredde();
                vindu.getVenstrepanel().settCelleRenderer();
                bunnController.settOppTabellData(modellIBruk);

            } catch (ArrayIndexOutOfBoundsException aiobe) {
                System.out.println("settInnDataITabell gir ArrayOutOfBounds ved innlegging av nytt datasett");
            } catch (NullPointerException npe) {
                System.out.println("settInnDataITabell gir NullPointer ved innlegging av nytt datasett");
            }//End Try/Catch

        }//End If datasett > 0
    }//End Metodet settInnDataITabell
        
\end{lstlisting}

Som man ser av metoden ovenfor så er det en del instruksjoner som gjøres for hvert datasett, men også noen unike for det enkelte datasett. F.eks så ser man at \texttt{Søknadsobjektene} sorteres med den tidligere metoden for den typen objekter. Til slutt i metoden så kjøres "resize"-metoden og formateringsmetoden. 

\subsubsection{Muselyttere og interaktivitet i tabellen} \label{sec:interaktivitettabell} 
De resterende \texttt{lytterne} er forskjellige "<muse-\texttt{lyttere}">, som responderer på enkeltklikk, dobbelklikk og høyreklikk i tabellen.

\texttt{Lytteren} som følger nå er laget for å gi ekstra funksjonalitet til annonsene. Det vil si at for annonser med flere bilder kan man klikke hvor som helst i output-vinduet og få opp en bildeviser og blå gjennom disse bildene. Denne bildefunksjonaliteten er beskrevet mer her \ref{sec:bilder}, på side \pageref{sec:bilder}.

\texttt{Lytteren} differensierer på om en er i annonsevinduet eller i meglervinduet. Er man i annonsevinduet så åpnes bildeviseren med den konstruktøren som ikke gir mulighet for å slette eller endre bildene. Dette er dog tillattet i meglervinduet, se eksempel \ref{kode:museklikk1}.
\begin{lstlisting}[caption=\texttt{Lytter} for museklikk i output-vinduet.,label=kode:museklikk1]
        vindu.getSenterpanel().getEditorPane().addMouseListener(new MouseAdapter() {

            @Override
            public void mouseClicked(MouseEvent e) {
                if (e.getButton() == MouseEvent.BUTTON1) {
                    if (modellIBruk instanceof TabellModellAnnonse) {
                        Annonse valgtObjekt = returnerAnnonseObjekt();
                        if (vindu instanceof ArkfaneMegler) {
                            new ControllerBildeViser(valgtObjekt.getBolig(), true);
                        } else {
                            new ControllerBildeViser(valgtObjekt.getBolig(), false);
                        }
                    }
                }
            }
        });

\end{lstlisting}


Den følgende \texttt{lytteren} som settes opp er del av tabellen sin \texttt{MouseAdapter}-implementasjon på lik linje som den som følger etter denne (eksempel \ref{kode:muslytt1}).
I \texttt{mouseClicked}-hendelsen når en dobbelklikker på en rad i tabellen vil starte opp registreringsvinduet for det valgte objektet og fylle ut all informasjon om objektet ut fra det som allerede er registrert. Så kan man endre objektet og trykk OK for å oppdatere objektet.
Eksempelet nedenfor dekker bare \texttt{Bolig}-objekter. Det settes en \texttt{lytter} på \texttt{kontrolleren} til registreringsvinduet som er koblet til \texttt{actionPerformed}-metoden til vinduet. I det man trykker OK så vil metoden \texttt{oppdaterTabellEtterEndring} kalles og den den tilhørende \texttt{TabellModell} vil oppdateres. Det vil si at tabellens innhold vil oppdatere seg med den nye endringer. Det forutsetter at man har rett \texttt{TabellModell} valgt. Feks så kan en ikke stå i \texttt{TabellModellPerson} og så opp endringene for en ny bolig som ble lagt til. 
Tabellens \texttt{TabellModeller} vil diskuteres i avsnittet \ref{sec:virkemåtetabell}, på side \pageref{sec:virkemåtetabell}.
\begin{lstlisting}[caption=Hendelse ved dobbelklikking på et objekt i tabellen.,label=kode:muslytt1]
			@Override
            public void mouseClicked(MouseEvent e) {

                if (e.getClickCount() == 2) {

                    if (tabellModellBolig.equals((TabellModell) tabell.getModel())) {
                        ControllerRegistrerBolig cont = new ControllerRegistrerBolig(boligliste, 				 returnerBoligObjekt());
                        cont.settTabellOppdateringsLytter(new TabellFireDataChangedInterface() {

                            @Override
                            public void oppdaterTabellEtterEndring() {
                                tabellModellBolig.fireTableDataChanged();
                            }
                        });
                    }
\end{lstlisting}


Den siste lytteren i metoden \texttt{settOppTabellLyttere} er \texttt{mouseReleased}-funksjonen på høyremuseknapp.
Det vil si når man høyreklikker i tabellen så vil en popupmeny dukke frem. De menyvalgene som dukker frem er avhengige av hvilket datasett man jobber på. Feks så kan man ikke høyreklikke på en annonse og så opp "<Ny Bolig">.

Det første utdraget (eks. \ref{kode:eks1}) fra koden gjelder for hvilket menyvalg som er tilgjenglig når en høyreklikker på en boligobjekt og et personobjekt. 
Det andre utdraget (eks. \ref{kode:eks2}) vil være fra metoden \texttt{settOpplyttereForTabellMenyITabell} som spesifiserer fuksjonaliteten til selve menyvalgene i pop-up menyen.
\begin{lstlisting}[caption=Menyvalg ved høyreklikk i tabellen.,label=kode:eks1]

            @Override
            public void mouseReleased(MouseEvent e) {
                if (e.getButton() == MouseEvent.BUTTON3) {

                    //Tømmer menyen før den tegnes på nytt.
                    tabellMeny.removeAll();

                    try {
                        if (tabellModellBolig.equals((TabellModell) tabell.getModel())) {
                            tabellMeny.add(menyvalgBolig);
                            menyvalgBolig.add(menyvalgEndreBolig);
                            menyvalgBolig.add(menyvalgSlettBolig);
                            menyvalgBolig.add(menyvalgPubliserToggle);

                        } else if (tabellModellPerson.equals((TabellModell) tabell.getModel())) {
                            tabellMeny.add(menyvalgPerson);
                            tabellMeny.add(menyvalgBolig);
                            menyvalgPerson.add(menyvalgNyPerson);
                            menyvalgPerson.add(menyvalgEndrePerson);
                            menyvalgPerson.add(menyvalgSlettPerson);
                            if (returnerPersonObjekt() instanceof Utleier) {
                                menyvalgBolig.add(menyvalgNyBolig);
                            }

                        }
\end{lstlisting} 


\begin{lstlisting}[caption=Funksjonaliteten til to av menyvalgene i pop-up menyen.,label=kode:eks2]
    public void settOpplyttereForPopupMenyITabell() {

        //Man ser bare dette valget om man høyreklikker på en utleier i tabellen
        menyvalgNyBolig.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                Person valgtObjekt = returnerPersonObjekt();
                if (valgtObjekt instanceof Utleier) {
                    ControllerRegistrerBolig cont = new ControllerRegistrerBolig(boligliste, (Utleier) valgtObjekt);
                    cont.settTabellOppdateringsLytter(new TabellFireDataChangedInterface() {
                        @Override
                        public void oppdaterTabellEtterEndring() {
                            tabellModellPerson.fireTableDataChanged();
                        }
                    });
                }
            }
        });

        //Endre bolig
        menyvalgEndreBolig.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                Bolig bolig = returnerBoligObjekt();
                if (bolig != null) {
                    ControllerRegistrerBolig cont = new ControllerRegistrerBolig(boligliste, bolig);
                    cont.settTabellOppdateringsLytter(new TabellFireDataChangedInterface() {
                        @Override
                        public void oppdaterTabellEtterEndring() {
                            tabellModellPerson.fireTableDataChanged();
                        }
                    });
                }
            }

        });

\end{lstlisting}




\subsection{Kontrollerne for registreringsvinduene} \label{sec:regkontrollere}

\subsubsection*{\texttt{AbstractControllerRegister.java}}
Alle kontrollere for registrerings vinduer finnes i pakken \texttt{controller.register}. Samtlige av disse kontrollene arver \texttt{AbstractControllerRegister.java} (eksempel \ref{kode:contreg1}) som er superklasse til registerkontrollene. Superklassen brukes til å håndtere lesing og skrivning av objekter til alle \texttt{HashSet} som brukes i de kontrollene. Klassen gjør at koden for lesing og skriving blir arvet av hver enkel kontroller. Ettersom det brukes flere forskjellige \texttt{HashSet} i programmet er superklassen satt opp med generisk parametre og begrenset til \texttt{Collection.Set.HashSet<E>}. Superklassen består av to konstruktører, den første blir kalt opp med en mengde som parameter og brukes ved registrering av nytt objekt f.eks. ny bolig. Nødvendige parametre for opprettelse av objektet blir hentet opp fra \texttt{gui} gjennom en kontroller som arver den superklassen. Den andre konstruktøren tas i bruk dersom et boligobjekt skal editeres, derfor blir det sent med et set og et generelt objekt som blir sendt fra markeringen i tabellen. Slik løsning er valgt etterom \texttt{HashSet} ikke tillater duplikater, hvilket brukes som en automatisk mekanisme for å unngå dobbelregistrering av data i registrene. Dersom man skal gjennomføre endringer i et eksisterende objekt i settet, må det objektet plukkes ut fra mengde, slettes fra mengde, deretter kan datafelt oppdateres og legges tilbake i mengden. Derfor blir objektet som skal endres direkte sendt med til den andre konstruktøren i superklassen.


\begin{lstlisting}[caption={[\texttt{AbstractControllerRegister.java}]\texttt{AbstractControllerRegister.java} kontroller arvet av alle regsitreringskontrollerene.},label=kode:contreg1]
public abstract class AbstractControllerRegister<E> {

    final HashSet<E> set;
    Object obj;

    public AbstractControllerRegister(HashSet<E> set) {
        this.set = set;
    }

    public AbstractControllerRegister(HashSet<E> set, Object obj) {
        this.set = set;
        this.obj = obj;
    }

    public boolean slettObjekt(E e) {
        return set.remove(e);
    }
    
    public boolean registrerObjekt(E e) {
        return set.add(e);
    }
}

\end{lstlisting}



\subsubsection*{\texttt{ControllerRegistrerBolig.java}}
Kontrolleren for boligvindu er satt opp med to konstruktører: en som sørger for registrering av en ny bolig, og den andre konstruktøren brukes til endring av eksisterende bolig (eksempel \ref{kode:boligregkont}). 
Som nevnt i avsnitt \ref{subsec:meglerpanel} (side \pageref{subsec:meglerpanel}) er det ikke mulig å registrere en bolig uten eier. Den første konstruktøren tar derfor for seg to parametre: (1) HashSet over bolig objekter og (2) person instansen Utleier. De to viktigste oppgavene til denne konstruktøren er å starte opp vinduet til boligbehandling samt kalle opp konstruktøren til superklassen slik at tilhørende HashSet kan behandles av denne. 
Den andre konstruktøren som finnes med i klassen tar med set HashSet og et bolig objekt som det skal endres på. Datafelt til objektet blir endret med data som tas imot fra GUI. Hvis data som tas imot fra GUI går igjennom regex testen (se eksempel \ref{kode:regex_bolig}) kan objektet blir oppdatert, slettet fra HashSet og lagt det opdaterte obejktet vil bli lagt til registeret (HashSet) på nytt (eksempel \ref{kode:regex_bolig2}). 



\begin{lstlisting}[caption={[\texttt{ControllerRegistrerBolig.java}]\texttt{ControllerRegistrerBolig.java}: Oversikt over konstruktører i bolig registrering/endring kontrolleren.}, label=kode:boligregkont]
    /**
     * En kontruktør for registrering av en ny bolig.
     *
     * @param boligSet HashSet<Bolig>
     */
    public ControllerRegistrerBolig(HashSet<Bolig> boligSet, Utleier utleier) {
        super(boligSet);
        erNyregistrering = true;
        boligBilde = new BoligBilde();
        bRegVindu = new BoligRegVindu("Registrering av boliger");
        bRegVindu.setKnappeLytter(new KnappeLytter());
        bRegVindu.getEierField().setText(String.valueOf(utleier.getPersonID()));
        bRegVindu.setIconImage(Ikoner.NY_BOLIG.getImage());
        bRegVindu.deaktiverBildeKnapper();
    }

    /**
     * En konstruktør som brukes for endring av en bolig.
     *
     * @param boligSet HashSet<Bolig>
     * @param bolig Bolig
     */
    public ControllerRegistrerBolig(HashSet<Bolig> boligSet, Bolig bolig) {
        super(boligSet, bolig);
        erNyregistrering = false;
        boligBilde = new BoligBilde();
        this.bolig = bolig;

        initialiseringAvController();

        bRegVindu.setIconImage(Ikoner.EDIT.getImage());
        
        //Sperrer mulighet til å gjøre om en leilighet til enebolig og vice versa
        bRegVindu.getLeilighetRButton().setEnabled(false);
        bRegVindu.getEneboligRButton().setEnabled(false);

    }
\end{lstlisting}



\begin{lstlisting}[caption={[\texttt{ControllerRegistrerBolig.java}]\texttt{ControllerRegistrerBolig.java}: Regex test av generelle tekstfelt for bolig.},label=kode:regex_bolig]
    private boolean kontrollerDataBolig() {
    
        boolean[] boligOK = new boolean[7];

        boligOK[0] = RegexTester.testID(String.valueOf(eierID));
        boligOK[1] = RegexTester.testID(String.valueOf(meglerID));
        boligOK[2] = RegexTester.testGateadresseEnkel(adresse);
        boligOK[3] = RegexTester.testPostNummer(postNr);
        boligOK[4] = RegexTester.testPostOrtNavn(postSted);
        boligOK[5] = RegexTester.testKVMbolig(String.valueOf(boAreal));
        boligOK[6] = RegexTester.testYearNummer(String.valueOf(byggeAr));
        for (int i = 0; i < boligOK.length; i++) {
            if (!boligOK[i]) {
                return false;
            }
        }
        return true;
    }
\end{lstlisting}


\begin{lstlisting}[caption={[\texttt{ControllerRegistrerBolig.java}]\texttt{ControllerRegistrerBolig.java}: Sletting og oppdatering av samme bolig objekt via superklassen til kontrolleren.},label=kode:regex_bolig2]
    private boolean slettBoligFraSet(Bolig bolig) {

        if (kontrollerDataForSletting(bolig)) {
            if (super.set.remove(bolig)) {
                return true;
            }
        }
        visMelding("slettBoligFraSet", "Bolig ble IKKE slettet fra set");
        return false;
    }
    
    private boolean skrivOppdateringTilBoligSet(Bolig bolig) {
        if (super.set.add(bolig)) {
            visMelding("skrivOppdateringTilBoligSet", "Boligen ble oppdatert i registret");
            return true;
        }
        visMelding("skrivOppdateringTilBoligSet", "Boligen ble IKKE oppdatert i registret");

        return false;
    }
\end{lstlisting}

En viktig funksjon i alle kontrollene til registreringsvinduer er initialisering av lyttere i disse klasser. Eller registreingsvinduer har en metode som kan sette en \texttt{ActionListener} til vinduene som blir sendt fra en kontrollere klasse. Hver kontrollerklasse innholder en privat kontroller klasse \texttt{KnappeLytter} (implementerer ActionListener), se eksempel \ref{kode:regex_bolig3}. Den private klassen blir alltid instasiert fra konstruktøren til registringskontrollere og sendt som parameter til vinduklassen (etter MVC arkitektur prinsipper).

\begin{lstlisting}[caption={[\texttt{ControllerRegistrerBolig.java}]\texttt{ControllerRegistrerBolig.java}: Uttdrag fra privat lytterklasse i kontrolleren.},label=kode:regex_bolig3]
    private class KnappeLytter implements ActionListener {

        @Override
        public void actionPerformed(ActionEvent e) {
            if (e.getSource().equals(bRegVindu.getLagreButton())) {

                if (erNyregistrering) {
                
                ...
\end{lstlisting}


Pakken for registreringskontrollene består av totalt seks klasser:
\begin{itemize}[noitemsep,nolistsep]
\item \texttt{AbstractControllerRegister.java}
\item \texttt{ControllerRegistrerAnnonse.java}
\item \texttt{ControllerRegistrerBolig.java}
\item \texttt{ControllerRegistrerLeietaker.java}
\item \texttt{ControllerRegistrerSoknad.java}
\item \texttt{ControllerRegistrerUtleier.java}
\end{itemize}

I dette avsnittet beskrives kun \texttt{ControllerRegistrerBolig.java} men de andre klassene i denne pakken har mer eller mindre densamme funksjonalitet. Det som er den største forskjellen mellom disse er preliminær t forskjellige antall tekstfelt i vinduene og noen andre typer at datafelt (f.eks. Calenderobjekt). Ettersom funksjonaliteten og strukturen på de klassene er så lik den klassen som beskrives i dette avsnittet her kommer vi ikke til å beskrive disse i detalj. For de spesielt interesserede henviser vi derfor til kildekoden (pakke \texttt{controller.register}).



\subsection{Innloggingskontroller}
Denne kontrollern lytter på arkfanen \texttt{Megler} via en \texttt{ChangeListener}. Dersom nevnt arkfane blir valgt, så sjekkes det hvorvidt man allerede er innlogget eller ei via. en static boolean variabel som er satt til \texttt{false} som standard. Dersom en ikke er innlogget, så vil man få mulighet til å logge inn via JDialog \texttt{LoggInnDialog.java}. Av enkelhets skyld, så har vi hardkodet en admin brukerkonto som kan brukes midlertidig, for å logge inn. Hjelpemetoden \texttt{sjekkAdmin()} eksisterer i sammenheng med dette. 

Klassen mottar et \texttt{HashSet<Person>} fra \texttt{Maincontroller.java} via konstruktøren, som inneholder alle person objekter lagret på fil, inkludert eventuelt megler brukerkontoer. Innloggingsknappen tilhørende \texttt{LoggInnDialog.java}, lyttes på via en \texttt{ActionListener}. Dersom knappen trykkes på, så kalles metoden \texttt{sjekkInformasjon()} opp, i tillegg til nevnt hjelpemetode \texttt{sjekkAdmin()}. 
Førstnevnte metode itererer igjennom HashSet, og sjekker hvorvidt det finnes en megler med det aktuelle brukernavnet og passordet, som er skrevet inn i LoggInnDialog vinduet. Ved en match, så blir boolean variabelen \texttt{innlogget} satt til \texttt{true}, og brukeren vil bli videreført til Megler arkfanen. Dersom det ikke blir funnet en match, får brukeren beskjed om dette gjennom et \texttt{JOptionPane.showMessageDialog()} vindu. Ved å trykke på avbryt i innloggingsvinduet, blir brukeren brakt tilbake igjen til Annonse arkfanen. 

\subsection{Tastatursnarveier: \texttt{ControllerKeyBindings}}
Denne kontrolleren mapper opp alle tastatursnarveier man kan bruke for å navigere i programmet. Via klassens konstruktør, så tas det imot de vindu objekter vi har behov for å jobbe med.
Gjennom vinduene sine get-metoder, så kaller vi opp \texttt{getInputMap()}, og \texttt{getActionMap()} metodene tilhørende det aktuelle GUI objektet vi ønsker å legge til en tastatursnarvei til. 

Som parametere i \texttt{getInputMap()} metoden, så brukes det en \texttt{JComponent} konstant for å sikre at den aktuelle tastatursnarveien kan brukes uavhengig av hvor i programvinduet brukeren har fokus. Dette i tilegg til det aktuelle KeyStroke objektet, samt en referanse til bruk i \texttt{getActionMap()} metoden. Som andre parameter i sistnevnte metode oppretter vi et Action objekt av en tilhørende privat klasse, som igjen styrer hvilken handling som skal utføres ved bruk av den aktuelle tastatursnarveien, se eksempel \ref{kode:tastsn1}.

\begin{lstlisting}[caption=Oppsett av tastatur snarveier.,label=kode:tastsn1]
        annonseVindu.getToppanelAnnonse().getSokeKnapp().getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke("ENTER"), "enterPressed");
        annonseVindu.getToppanelAnnonse().getSokeKnapp().getActionMap().put("enterPressed", new EnterActionAnnonse());
    }

    private class EnterActionAnnonse extends AbstractAction {

        @Override
        public void actionPerformed(ActionEvent e) {
            annonseVindu.getToppanelAnnonse().getSokeKnapp().doClick();
        }
    }
\end{lstlisting}    



\subsection{Lyttere mellom forskjellige \texttt{kontrollere} i programmet} \label{sec:kontrollerlyttere}

\texttt{Kontrollerne} er i hovedsak uavhengig av hverandre. Det vil si at \texttt{ControllerTabell.java} ikke kan kontakte \texttt{ControllerToppPanelMegler.java} direkte. Selv om denne problematikken i akkurat dette tilfelle kunne løses ved bruk av å teste på tabellens \texttt{getModel}-metode og finne ut hvilken data som ligger i tabellen, så har vi tatt vare på denne implementasjonen som ble brukt før vi hadde en solid tabell-implementasjon.

Det finnes flere eksempler som fungerer på tilsvarende måter andre steder i programmet, men det er lettest å visualisere dette eksempelet.

Målet er altså at i det øyeblikket et søk blir gjort i \texttt{ToppPanelet} så skal resultatet sendes til \texttt{ControllerTabell.java} for å settes inn i rett \texttt{TabellModell}.
Vi har et \texttt{interface} som heter \texttt{ListListenerInterface.java} som har to metoder. Den ene metoden tar i mot en \texttt{ArrayList} og et \texttt{Enum}-objekt.
\texttt{ControllerToppPanelAnnonse.java} har en metode som følgende (eks \ref{kode:snutt1}):

\begin{lstlisting}[caption={[\texttt{ControllerToppPanelAnnonse.java}]\texttt{setListListener}-metoden fra \texttt{ControllerToppPanelAnnonse.java}},label=kode:snutt1]
    public void setListListener(ListListenerInterface listListener) {
        this.listListener = listListener;
    }
\end{lstlisting}

Metoden blir kalt opp allerede i \texttt{konstruktøren} til \texttt{MainController.java} under oppstart av programmet, via denne instruksjonen:

\begin{lstlisting}[caption=Setter lytter fra \texttt{MainController.java},label=kode:snutt2]
        toppPanelControllerAnnonse.setListListener(new ListListenerInterface() {

            @Override
            public void listReady(ArrayList liste, ObjektType obj) {
                //Brukes ikke her
            }

            @Override
            public void listReady(HashSet liste, ObjektType objekttype) {
                tabellControllerAnnonse.tomTabellOgKlargjorForNyttDatasett();
                tabellControllerAnnonse.settInnDataITabell(liste, objekttype);
                liste.clear();
            }
        });
\end{lstlisting}

Foreløpig er det ikke en fungerende løsning. I \texttt{sendSokeResultat}-metoden i \texttt{ControllerToppPanelAnnonse.java} så ligger følgende instruksjon helt til slutt:
\begin{lstlisting}[caption={[\texttt{ControllerToppPanelAnnonse.java}]Utdrag fra \texttt{sendSokeResultat}-metoden i \texttt{ControllerToppPanelAnnonse.java}},label=kode:snutt3]

            else if (listListener != null) {
                listListener.listReady(sokeResultat, radioTypeValgt);
            }
\end{lstlisting}

Det som skjer nå er at hver gang det blir gjort et søk så kalles \texttt{lytteren listListener} sin \texttt{listReady}-funksjon opp, der det sendes med søkeresultatet og en identifikator på hvilken type objekter som finnes i søkeresultatet.
Hvis man ser på kodeeksempel \ref{kode:snutt2} så er det her det nå kommer inn et datasett fra \texttt{Toppanelet} og det sendes da videre til rett metode i \texttt{ControllerTabell}.
Her har vi altså brukt et \texttt{interface} til å være bindeledd mellom komponenter som eller ikke kjenner til hverandre. Det samme gjøres i uttstrakt bruk i tabellens "<museklikk">-metoder, både ved høyreklikk og dobbelklikk er det hengt på en \texttt{lytter} som vet når noe er utført og en \texttt{event} skal utføres.
 
